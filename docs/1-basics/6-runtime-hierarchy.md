# 1-6. ランタイムのレイヤとエコシステム

## コンテナランタイムの実用化

### コンテナランタイムに求められる役割

コンテナを**便利で実用的に**扱いたいとなると、

- 今**どんなコンテナが立っているのか**、外部から知りたい
  - プロセスを闇雲に探しても不可能/効率が悪い
- 変更する先のルートディレクトリの中身を共通化して、**同じ環境を再現**したい
- コンテナ (プロセス) は**再起動で消える**ので、再起動したら同じ設定で**コンテナを立て直し**たい
- **複数コンテナにまたがるネットワーク**が組みたい
- もっと少ない設定項目で便利に扱いたい

などなど... 様々な要望が出てきます。

これらの要望が**あらかた叶い**、コンテナが「使いやすい技術」になったのは、**Dockerの登場**が大きな転換点だったと言えるでしょう。

### Dockerが成し遂げたこと

皆さんの中には、**Dockerが世界初のコンテナランタイム**だと思っている人も多いでしょう。しかし、それは**大きな間違い**です。

**Jail**や**LXC**等、2000年代までにある程度しっかりしたコンテナランタイムは誕生していました。  
ただこれらは**プロセスを隔離環境で動かすツール**という扱いであり、セキュリティ面の長所はあれど、今のように**大規模なデプロイ**に使うにはピースが欠けた状態でした。

その**穴を埋めた**のがDockerです。  
Dockerが発表された当時、Dockerの中で実際にコンテナを作っていたのはLXCという**前世代のコンテナランタイム**でした。コンテナの作成に対して新しいことはしていなかったのです。  
彼らが提供したのはコンテナの**便利なAPI**と**コンテナイメージ**という概念。  
コンテナの**ルートディレクトリに配置**したいファイル群を**まとめて配布**することにより、**同じ環境**を**軽量かつ大量**に起動するための最後のピースが埋まったのでした。

### コンテナランタイムの細分化

最終的にDockerは、**libcontainer**という独自のコンテナ作成機構を作り、それをデフォルトとしました。  
Dockerは**イメージの作成・管理**から実際の**コンテナ作成**までを担う、巨大プロジェクトになったのです。

しかし、他社が次々とコンテナランタイムを出す中で、**コンテナイメージ**と**コンテナ作成機構**の**標準仕様**を策定する**OCI** (Open Container Initiative) という団体ができ、libcontainerは切り出され**runc**になりました。

さらに、はじめDockerしかサポートしていなかったKubernetesが他のランタイムもサポートしようとする中、**CRI** (Container Runtime Interface) という仕様が導入されました。  
CRIプラグインはruncのような**コンテナ作成ソフトウェアを使役**し、デーモンとして**便利なAPIを提供**することが求められます。  
Dockerもこれを受け、CRIプラグインに必要な機能を抜き出して**containerd**として分離し、残った部分を**moby**として管理し始めたのです。

このような経緯で、現在のDockerは

- moby (containerdより高レイヤーだった部分)
- containerd (コンテナ管理デーモン)
- runc (コンテナ作成ソフトウェア)

の3つを合わせて提供する形になりました。

## ランタイムのレイヤ

以上の経緯でコンテナランタイムは**レイヤ分割**がされており、それぞれ以下のような名前と役割を持っています。

### コンテナエンジン

- **Docker**(moby)/**Podman**など
- ランタイム全体を束ね、**ユーザーが使いやすい機能**を提供
- **コンテナイメージの作成**が統合されていることもある
  - 作成はこれより下のレイヤには無い

![Docker](/1-basics/1.png){width=300}

![Podman](/1-basics/2.png){width=300}

### 高レベルランタイム (CRIプラグイン)

- **containerd**/**CRI-O**など
- デーモンとして**ソケット通信ベース**のAPIを提供
- **コンテナイメージを解釈**し、低レベルランタイム用のファイルを用意
- 複数コンテナにまたがる**ネットワーク**の管理
- 低レベルコンテナランタイムに指令を出す

![containerd](/1-basics/13.png){width=300}

![CRI-O](/1-basics/14.png){width=300}

### 低レベルコンテナランタイム (OCIランタイム)

- **runc**/**youki**/**crun**など
- 実際のコンテナ作成を担当

![youki](/1-basics/15.png){width=200}
![crun](/1-basics/16.png){width=200}

### 各レイヤの繋がり

これらのエコシステムは、全体として以下のような連関で成り立っています。

![エコシステム](/1-basics/17.dio.png)

ここまでのことを踏まえ、このワークショップの冒頭に書いた「『docker run』コマンドを実行してからアプリケーションのプロセスが動き始めるまでに**どんなソフトウェアがどんな役割を果たしている**か」という質問への答えは以下です。

- `docker run`が実行される
- Dockerがcontainerdにコンテナ作成を指令
- containerdがイメージをダウンロード
- containerdがイメージを解凍
- containerdがruncにコンテナ作成を指令
- runcがプロセスを立て、コンテナに仕立て上げる

さあ、コンテナについてある程度理解できましたか？  
いよいよここから実装パートに入っていきましょう！
